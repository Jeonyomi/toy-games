<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#07030f" />
  <title>Neon Tank vs Matrix Girls</title>
  <link rel="stylesheet" href="../ui-common.css" />
  <link rel="stylesheet" href="../shared-nav.css" />
  <link rel="stylesheet" href="style.css" />

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <main class="wrap">
    <div class="marquee">üéÆ BB ARCADE :: NEON TANK MODE</div>
    <div class="cabinet-deco" aria-hidden="true"><span class="coin-slot"></span></div>

    <div class="h1row">
      <h1 style="margin:0">üõ°Ô∏è Neon Tank <span class="ver">v1</span></h1>
      <p class="sub">Move, jump, shoot. Charge energy to unleash ULTIMATE.</p>
    </div>

    <nav class="universal-actions" aria-label="Universal game actions">
      <a class="ua-btn" href="../index.html">Home</a>
      <button class="ua-btn" type="button" data-action="change-game">Change Game</button>
      <button id="restartPage" class="ua-btn" type="button">Restart</button>
    </nav>

    <section class="stage" aria-label="game stage">
      <div id="flash"></div>

      <div id="ui">
        <div id="score">SCORE: 0</div>
        <div id="energy-bar-container"><div id="energy-bar"></div></div>
        <div id="special-ready">ULTIMATE READY! PRESS [Z]</div>
      </div>

      <div id="game-over" role="dialog" aria-modal="true">
        <div class="card">
          <h1>TANK DOWN</h1>
          <p>Final Score: <span id="final-score" style="font-weight: 900; color: #0ff;">0</span></p>
          <button id="restart-btn">Restart System</button>
        </div>
      </div>

      <div id="instructions">
        <span class="key">[ARROWS]</span> Move | <span class="key">[SPACE]</span> Jump | <span class="key">[X]</span> Shoot | <span class="spec">[Z]</span> ULTIMATE
      </div>

      <div id="stageMount" style="position:absolute;inset:0"></div>
    </section>

    <label class="crt-toggle"><input id="crtToggle" type="checkbox" /> CRT Effect (Visual Only)</label>
  </main>

  <script>
    (function(){
      const key='bb_arcade_crt';
      const wrap=document.querySelector('.wrap');
      const t=document.getElementById('crtToggle');
      const saved=localStorage.getItem(key);
      const on=saved==='1';
      if(on){wrap.classList.add('crt-on'); t.checked=true;}
      t.addEventListener('change',()=>{wrap.classList.toggle('crt-on',t.checked); localStorage.setItem(key,t.checked?'1':'0');});

      document.getElementById('restartPage').addEventListener('click',()=>location.reload());
    })();
  </script>

  <script src="../shared-nav.js"></script>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // 1. Core Scene Setup
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.015);

    const mount = document.getElementById('stageMount');

    const camera = new THREE.PerspectiveCamera(70, mount.clientWidth / mount.clientHeight, 0.1, 1000);
    camera.position.set(0, 8, 16);
    let cameraTarget = new THREE.Vector3(0, 0, -10);
    camera.lookAt(cameraTarget);

    const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
    renderer.setSize(mount.clientWidth, mount.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    mount.appendChild(renderer.domElement);

    // 2. Post Processing (Bloom)
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(mount.clientWidth, mount.clientHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0;
    bloomPass.strength = 1.2;
    bloomPass.radius = 0.5;

    const composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // 3. Environment (Synthwave floor + particles)
    const gridGroup = new THREE.Group();
    const gridHelper = new THREE.GridHelper(400, 100, 0x00ffff, 0xff00ff);
    gridHelper.position.y = -0.5;
    gridGroup.add(gridHelper);

    const groundGeo = new THREE.PlaneGeometry(400, 400);
    const groundMat = new THREE.MeshBasicMaterial({ color: 0x050010, side: THREE.DoubleSide });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = Math.PI / 2;
    ground.position.y = -0.55;
    gridGroup.add(ground);
    scene.add(gridGroup);

    // Floating particles
    const particleGeo = new THREE.BufferGeometry();
    const pCount = 2000;
    const pPos = new Float32Array(pCount * 3);
    for (let i = 0; i < pCount * 3; i++) pPos[i] = (Math.random() - 0.5) * 200;
    particleGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
    const particleMat = new THREE.PointsMaterial({
      color: 0x00ffff,
      size: 0.1,
      transparent: true,
      opacity: 0.6,
      blending: THREE.AdditiveBlending
    });
    const particles = new THREE.Points(particleGeo, particleMat);
    scene.add(particles);

    // 4. The Player (Cyber Tank)
    const tank = new THREE.Group();

    const bodyGeo = new THREE.BoxGeometry(2.4, 1.2, 4);
    const hullMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9, roughness: 0.1 });
    const body = new THREE.Mesh(bodyGeo, hullMat);
    body.position.y = 0.6;
    tank.add(body);

    const stripGeo = new THREE.BoxGeometry(2.5, 0.1, 4.1);
    const stripMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
    const strip = new THREE.Mesh(stripGeo, stripMat);
    strip.position.y = 0.2;
    tank.add(strip);

    const turretGeo = new THREE.BoxGeometry(1.6, 1.0, 2);
    const turretMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8 });
    const turret = new THREE.Mesh(turretGeo, turretMat);
    turret.position.y = 1.7;
    turret.position.z = 0.5;
    tank.add(turret);

    const cannonGeo = new THREE.CylinderGeometry(0.2, 0.3, 3);
    cannonGeo.rotateX(Math.PI / 2);
    const cannonMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 1 });
    const cannon = new THREE.Mesh(cannonGeo, cannonMat);
    cannon.position.set(0, 1.7, -1.5);
    tank.add(cannon);

    const cannonLightGeo = new THREE.TorusGeometry(0.3, 0.05, 8, 16);
    const cannonLightMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
    const cannonLight = new THREE.Mesh(cannonLightGeo, cannonLightMat);
    cannonLight.position.set(0, 1.7, -3);
    tank.add(cannonLight);

    scene.add(tank);
    tank.position.y = 0;

    const basePlayerY = 0;
    const playerBox = new THREE.Box3();

    // 5. Enemies (Cute Girls) via SVG
    const svgContent = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
          <path d="M 30 90 l -10 10 h 60 l -10 -10 v -30 h -40 z" fill="#ff00ff" />
          <path d="M 40 60 h 20 v 30 h -20 z" fill="#ff66ff" />
          <circle cx="50" cy="40" r="22" fill="#ffe0c8" />
          <ellipse cx="40" cy="40" rx="4" ry="6" fill="#f00" />
          <ellipse cx="60" cy="40" rx="4" ry="6" fill="#f00" />
          <circle cx="35" cy="46" r="3" fill="#ff9999" opacity="0.8" />
          <circle cx="65" cy="46" r="3" fill="#ff9999" opacity="0.8" />
          <path d="M 46 48 q 4 5 8 0" stroke="#f00" stroke-width="2" fill="none" />
          <path d="M 20 40 c 0 -40, 60 -40, 60 0 v 30 h -10 v -30 c 0 -20, -40 -20, -40 0 v 30 h -10 z" fill="#00ffff" />
          <circle cx="20" cy="25" r="12" fill="#0ff" />
          <circle cx="80" cy="25" r="12" fill="#0ff" />
        </svg>`;

    const girlUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgContent);
    const girlTexture = new THREE.TextureLoader().load(girlUrl);
    const enemyMaterial = new THREE.SpriteMaterial({ map: girlTexture });

    const enemies = [];
    const missiles = [];
    const enemyBox = new THREE.Box3();
    const missileBox = new THREE.Box3();

    // 6. Lights
    scene.add(new THREE.AmbientLight(0x404040, 2));
    const dirLight = new THREE.DirectionalLight(0xffffff, 3);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    // 7. Inputs
    const keys = { left: false, right: false, x: false, z: false };

    // Jump state
    let playerVelY = 0;
    let isJumping = false;
    const gravity = -0.02;
    const jumpPower = 0.4;

    // Game State
    let isGameOver = false;
    let score = 0;
    let energy = 0;
    let speed = 0.8;

    // Camera shake
    let shakeAmount = 0;

    // UI Elements
    const scoreEl = document.getElementById('score');
    const energyBar = document.getElementById('energy-bar');
    const specReady = document.getElementById('special-ready');
    const gameOverEl = document.getElementById('game-over');
    const finalScoreEl = document.getElementById('final-score');
    const flashEl = document.getElementById('flash');

    function updateUI() {
      scoreEl.innerText = 'SCORE: ' + score;
      const ePercent = Math.min(100, energy);
      energyBar.style.width = ePercent + '%';
      specReady.style.display = energy >= 100 ? 'block' : 'none';
    }

    function spawnEnemy() {
      if (isGameOver) return;
      const enemy = new THREE.Sprite(enemyMaterial);
      enemy.scale.set(4, 4, 1);
      enemy.position.x = (Math.random() - 0.5) * 28;
      enemy.position.y = 2;
      enemy.position.z = -100 - Math.random() * 40;

      enemy.userData.yOffset = Math.random() * Math.PI;
      enemy.userData.isFlying = Math.random() > 0.7;
      if (enemy.userData.isFlying) enemy.position.y += 3;

      scene.add(enemy);
      enemies.push(enemy);

      const rate = Math.max(100, 600 - score * 2);
      setTimeout(spawnEnemy, rate + Math.random() * 200);
    }
    setTimeout(spawnEnemy, 1000);

    function shootMissile() {
      if (isGameOver) return;
      const mGeo = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
      mGeo.rotateX(Math.PI / 2);
      const mMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
      const missile = new THREE.Mesh(mGeo, mMat);

      missile.position.copy(tank.position);
      missile.position.y += 1.7;
      missile.position.z -= 3;
      scene.add(missile);
      missiles.push({ mesh: missile });

      cannon.position.z = -1.0;
      shakeAmount = 0.2;
    }

    const explosionSpheres = [];
    const exGeo = new THREE.IcosahedronGeometry(1.5, 1);
    function createExplosion(pos, tColor = 0xff00ff) {
      const exMat = new THREE.MeshBasicMaterial({ color: tColor, wireframe: true, transparent: true });
      const exp = new THREE.Mesh(exGeo, exMat);
      exp.position.copy(pos);
      scene.add(exp);
      explosionSpheres.push({ mesh: exp, scale: 1, life: 1.0 });
      shakeAmount += 0.5;
    }

    function triggerUltimate() {
      if (isGameOver || energy < 100) return;
      energy = 0;
      updateUI();

      flashEl.style.transition = 'opacity 0.1s';
      flashEl.style.opacity = 0.8;
      setTimeout(() => {
        flashEl.style.transition = 'opacity 1.5s ease-out';
        flashEl.style.opacity = 0;
      }, 100);

      const laserGeo = new THREE.CylinderGeometry(15, 15, 200, 16);
      laserGeo.rotateX(Math.PI / 2);
      const laserMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });
      const giantLaser = new THREE.Mesh(laserGeo, laserMat);
      giantLaser.position.copy(tank.position);
      giantLaser.position.z -= 100;
      scene.add(giantLaser);

      shakeAmount = 4.0;

      enemies.forEach(en => {
        createExplosion(en.position, 0xffffff);
        scene.remove(en);
        score += 50;
      });
      enemies.length = 0;
      updateUI();

      let fade = setInterval(() => {
        giantLaser.scale.x *= 0.8;
        giantLaser.scale.y *= 0.8;
        laserMat.opacity -= 0.05;
        if (laserMat.opacity <= 0) {
          scene.remove(giantLaser);
          clearInterval(fade);
        }
      }, 30);
    }

    window.addEventListener('keydown', (e) => {
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
      if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
      if (e.code === 'Space' && !isJumping && !isGameOver) {
        playerVelY = jumpPower; isJumping = true;
      }
      if (e.code === 'KeyX' && !keys.x) { shootMissile(); keys.x = true; }
      if (e.code === 'KeyZ' && !keys.z) { triggerUltimate(); keys.z = true; }
    });

    window.addEventListener('keyup', (e) => {
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
      if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
      if (e.code === 'KeyX') keys.x = false;
      if (e.code === 'KeyZ') keys.z = false;
    });

    document.getElementById('restart-btn').addEventListener('click', () => {
      isGameOver = false;
      score = 0; energy = 0; speed = 0.8;
      tank.position.set(0, 0, 0);
      isJumping = false; playerVelY = 0;
      updateUI();
      gameOverEl.style.display = 'none';
      camera.position.set(0, 8, 16);

      enemies.forEach(e => scene.remove(e)); enemies.length = 0;
      missiles.forEach(m => scene.remove(m.mesh)); missiles.length = 0;

      spawnEnemy();
      animate();
    });

    // 10. Main Loop
    function animate() {
      if (isGameOver) return;
      requestAnimationFrame(animate);

      const time = Date.now() * 0.005;

      const movSpeed = 0.4;
      let tiltTarget = 0;
      if (keys.left && tank.position.x > -14) { tank.position.x -= movSpeed; tiltTarget = 0.15; }
      if (keys.right && tank.position.x < 14) { tank.position.x += movSpeed; tiltTarget = -0.15; }
      tank.rotation.z = THREE.MathUtils.lerp(tank.rotation.z, tiltTarget, 0.1);

      if (isJumping) {
        tank.position.y += playerVelY;
        playerVelY += gravity;
        tank.rotation.x = playerVelY * -0.2;
        if (tank.position.y <= basePlayerY) {
          tank.position.y = basePlayerY;
          tank.rotation.x = 0;
          isJumping = false;
          playerVelY = 0;
          shakeAmount = 0.3;
          createExplosion(tank.position, 0x00ffff);
        }
      }

      cannon.position.z = THREE.MathUtils.lerp(cannon.position.z, -1.5, 0.1);

      gridGroup.position.z += speed;
      if (gridGroup.position.z > 10) gridGroup.position.z -= 10;

      const positions = particleGeo.attributes.position.array;
      for (let i = 1; i < pCount * 3; i += 3) {
        positions[i - 1] -= 0.02;
        positions[i + 1] += speed * 2;
        if (positions[i + 1] > 20) {
          positions[i + 1] = -180;
          positions[i] = (Math.random() * 20) - 5;
        }
      }
      particleGeo.attributes.position.needsUpdate = true;

      if (shakeAmount > 0) {
        camera.position.x = (Math.random() - 0.5) * shakeAmount;
        camera.position.y = 8 + (Math.random() - 0.5) * shakeAmount;
        shakeAmount *= 0.9;
        if (shakeAmount < 0.01) shakeAmount = 0;
      } else {
        camera.position.x = 0; camera.position.y = 8;
      }

      playerBox.setFromObject(tank);
      playerBox.expandByScalar(-0.6);

      for (let i = missiles.length - 1; i >= 0; i--) {
        const m = missiles[i];
        m.mesh.position.z -= 3.0;
        missileBox.setFromObject(m.mesh);

        let hit = false;
        for (let eIdx = enemies.length - 1; eIdx >= 0; eIdx--) {
          const en = enemies[eIdx];
          enemyBox.setFromObject(en);
          if (missileBox.intersectsBox(enemyBox)) {
            createExplosion(en.position, 0xff00ff);
            scene.remove(en);
            enemies.splice(eIdx, 1);
            hit = true;
            score += 30;
            energy = Math.min(100, energy + 5);
            updateUI();
            break;
          }
        }
        if (hit || m.mesh.position.z < -100) {
          scene.remove(m.mesh);
          missiles.splice(i, 1);
        }
      }

      for (let i = enemies.length - 1; i >= 0; i--) {
        const en = enemies[i];
        en.position.z += speed * 1.2;
        if (en.userData.isFlying) en.position.y = 5 + Math.sin(time + en.userData.yOffset) * 2;
        else en.position.y = 2 + Math.abs(Math.sin(time * 2 + en.userData.yOffset)) * 0.5;

        enemyBox.setFromObject(en);
        enemyBox.expandByScalar(-0.8);

        if (playerBox.intersectsBox(enemyBox)) {
          isGameOver = true;
          finalScoreEl.innerText = score;
          gameOverEl.style.display = 'grid';
          createExplosion(tank.position, 0xff0000);
          shakeAmount = 2.0;
          break;
        }

        if (en.position.z > 20) {
          scene.remove(en);
          enemies.splice(i, 1);
        }
      }

      if (Math.random() < 0.05) score++;
      if (Math.random() < 0.1) {
        energy = Math.min(100, energy + 0.1);
        updateUI();
      }

      for (let i = explosionSpheres.length - 1; i >= 0; i--) {
        const exp = explosionSpheres[i];
        exp.scale += 0.3;
        exp.mesh.scale.set(exp.scale, exp.scale, exp.scale);
        exp.life -= 0.05;
        exp.mesh.material.opacity = exp.life;
        if (exp.life <= 0) {
          scene.remove(exp.mesh);
          explosionSpheres.splice(i, 1);
        }
      }

      if (score > 0 && score % 1000 === 0) speed += 0.05;

      composer.render();
    }

    function resize() {
      const w = mount.clientWidth;
      const h = mount.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
      composer.setSize(w, h);
    }

    window.addEventListener('resize', resize);
    resize();
    updateUI();
    animate();
  </script>
</body>
</html>
